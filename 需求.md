# Bot介绍
一个 Telegram Bot，用于将媒体以 Telegram file_id 的形式“索引存储”为合集，并通过 固定 token 的深链接分享合集。 

# 功能概览 
## 1.1 管理员（Admin）
### /start → 按钮菜单

✏️ 自定义 /start 欢迎消息：

支持管理员直接输入文本并包含 Premium Emoji（无需转义）

支持占位符渲染（如 {{user_first_name}} / {{collection_title}}）

保存后对所有访客/订阅者在 /start 入口生效（含深链入口前置文案）

### /upload 文件上传

连续发送/转发媒体（photo/video/document/audio）

去重（基于 unique_file_id）

完成上传 → 填写标题/描述 → 💾 储存

保存成功后：

固化合集（collection）

生成并固定深链 token（一个合集永远一个 token）

返回“储存完成 + 深链接”

### /display 合集文件展示
合集文件列表（管理员）：

管理员在面板可查看全部已保存合集（按合集维度展示，不直接平铺原始文件）

支持分页、按标题(模糊匹配)/创建者/日期筛选，进入后可查看合集统计与深链

### /publish 推送
全员推送（管理员）：

向所有激活 Bot 的成员发送一条消息，支持占位符渲染与直接输入 Premium Emoji

## 1.2 用户（User）
### /start 

展示合集页

打开深链后发送该合集下的所有媒体文件，并显示合集统计与发送情况

## 1.3 自动搬运（Admin 控制 + userbot worker）

管理员可开启/关闭自动搬运开关，由控制 Bot 下发任务给 userbot worker

worker 将指定频道消息转发到存储 Bot，支持三种范围：全部转发 / 按日期转发 / 按文件类型转发

按文件类型转发时需识别媒体组（album）内混合图片/视频并按条目类型精确过滤

# 技术架构

## 2.1 技术选型

### 核心框架
- **Bot 框架**：grammY + TypeScript
  - 原因：深链接支持好、会话管理强大、类型安全
  - 插件：@grammyjs/conversations (多步骤上传流程)
- **通信方式**：Long Polling（非 webhook）
  - 原因：连续上传更稳定、开发调试方便、无需公网 IP/SSL

### 数据存储
- **数据库**：PostgreSQL
  - collections 表：id, title, description, token, creator_id, created_at
  - media_files 表：id, collection_id, file_id, unique_file_id, type, order
  - users 表：id, telegram_id, is_admin, first_name, activated_at
  - settings 表：key, value (存储欢迎消息等配置)
- **ORM**：Prisma (类型安全 + 自动迁移)

### Userbot 集成
- **框架**：GramJS (官方 MTProto 实现)
- **功能**：监听频道消息 → 转发到 Bot → 自动归档

### 辅助工具
- **Token 生成**：nanoid (短 hash，适合深链)
- **模板渲染**：正则替换或 handlebars (占位符渲染)
- **部署**：Docker + PM2

## 2.2 项目目录结构

```
RSB-TgBot/
├── src/
│   ├── bot/
│   │   ├── index.ts              # Bot 主入口
│   │   ├── commands/             # 命令处理器
│   │   │   ├── start.ts          # /start 深链解析
│   │   │   ├── upload.ts         # /upload 上传流程
│   │   │   ├── display.ts        # /display 合集展示
│   │   │   └── publish.ts        # /publish 全员推送
│   │   ├── conversations/        # 多步骤会话
│   │   │   ├── uploadFlow.ts    # 上传→填写信息→保存
│   │   │   └── customizeStart.ts # 自定义欢迎消息
│   │   ├── middlewares/
│   │   │   ├── auth.ts           # 管理员权限检查
│   │   │   └── session.ts        # 会话管理
│   │   └── handlers/
│   │       ├── media.ts          # 媒体文件处理
│   │       └── callback.ts       # 按钮回调处理
│   ├── userbot/
│   │   ├── index.ts              # Userbot 主入口
│   │   ├── worker.ts             # 自动搬运逻辑
│   │   └── filters.ts            # 日期/类型过滤器
│   ├── database/
│   │   ├── schema.prisma         # Prisma 数据模型
│   │   ├── client.ts             # 数据库连接
│   │   └── migrations/           # 数据库迁移文件
│   ├── services/
│   │   ├── collection.ts         # 合集 CRUD
│   │   ├── media.ts              # 媒体文件管理
│   │   ├── user.ts               # 用户管理
│   │   └── template.ts           # 模板渲染服务
│   └── utils/
│       ├── token.ts              # Token 生成
│       ├── dedup.ts              # 去重逻辑
│       └── logger.ts             # 日志工具
├── prisma/
│   └── schema.prisma             # Prisma schema
├── .env                          # 环境变量
├── .env.example
├── package.json
├── tsconfig.json
├── Dockerfile
└── docker-compose.yml
```

## 2.3 技术难点与解决方案

### 难点 1：连续上传的会话状态管理
**问题**：用户连续发送多个媒体 → 输入标题/描述 → 保存，需要保持状态
**解决方案**：
- 使用 grammY conversations 插件
- 会话数据临时存储在内存或 Redis
- 超时自动清理未完成的上传

### 难点 2：媒体去重（unique_file_id）
**问题**：同一文件可能被多次上传，需要基于 `unique_file_id` 去重
**解决方案**：
- 数据库 `unique_file_id` 字段建立唯一索引
- 上传前查询是否已存在，存在则跳过并提示

### 难点 3：深链 Token 的唯一性与固定性
**问题**：每个合集需要一个永久不变的短 token
**解决方案**：
- 使用 `nanoid` 生成 8-10 位短 hash
- 数据库 token 字段唯一索引，冲突时重新生成
- 合集创建时生成，后续不可修改

### 难点 4：自动搬运的媒体组（album）识别
**问题**：Telegram 的 album 会作为多条消息发送，需要识别并按类型过滤
**解决方案**：
- 监听 `message.media_group_id`，相同 ID 的消息属于同一 album
- 缓存 media_group_id，延迟 1-2 秒后批量处理
- 按文件类型过滤时，逐条检查 `message.photo`/`message.video` 等

### 难点 5：全员推送的性能与限流
**问题**：向所有用户推送消息，可能触发 Telegram 限流
**解决方案**：
- 分批发送，每批 30 条，间隔 1 秒
- 记录发送失败的用户（bot 被 block），标记为非激活状态
- 使用队列（如 Bull）异步处理

### 难点 6：Premium Emoji 的存储与渲染
**问题**：Premium Emoji 是特殊 Unicode，需要正确存储和显示
**解决方案**：
- 数据库使用 UTF-8mb4 编码
- 直接存储原始文本，Telegram API 自动渲染
- 无需转义或特殊处理

### 难点 7：占位符渲染的安全性
**问题**：用户输入的模板可能包含恶意代码或注入
**解决方案**：
- 仅支持白名单占位符（如 `{{user_first_name}}`）
- 使用正则替换，不使用 eval 或动态执行
- 对用户输入进行 HTML 转义（如果涉及 Web 展示）
