# Bot介绍
一个 Telegram Bot，用于将媒体以 Telegram file_id 的形式"索引存储"为合集，并通过 固定 token 的深链接分享合集。

# 功能概览
## 1.1 管理员（Admin）
### /start → 欢迎消息 + 合集列表

显示自定义欢迎消息（支持占位符渲染）

显示所有可访问的合集列表（分页显示，每页10个）

每个合集显示：标题、描述、文件数量、深链接、创建日期

支持翻页按钮浏览更多合集

### /setwelcome 自定义欢迎消息

管理员可设置 /start 命令的欢迎消息

支持占位符：{{user_first_name}}、{{user_last_name}}、{{user_username}}

支持 Premium Emoji（无需转义）

### /upload 文件上传

连续发送/转发媒体（photo/video/document/audio）

去重（基于 unique_file_id）

完成上传 → 填写标题/描述 → 💾 储存

标题相同的合集会自动追加文件（描述会被覆盖）

保存成功后：
- 固化合集（collection）
- 生成并固定深链 token（一个合集永远一个 token）
- 返回"储存完成 + 深链接 + 编辑/删除按钮"

### /display 合集文件展示

管理员查看全部已保存合集

显示合集 ID、标题、文件数量、深链接、创建日期

提示使用 /edit <ID> 编辑合集，/delete <ID> 删除合集

### /edit <ID> 编辑合集

显示合集信息和文件列表

提供"编辑标题/描述"按钮

为每个文件提供删除按钮（每行2个按钮）

点击删除按钮会显示文件预览并请求确认

编辑标题时，如果新标题与其他合集重复，会自动合并文件

### /delete <ID> 删除合集

删除指定合集及其所有文件

需要确认才能删除

### /publish 推送

向所有激活 Bot 的成员发送一条消息

支持占位符渲染与直接输入 Premium Emoji

## 1.2 用户（User）
### /start

无参数时：
- 显示欢迎消息
- 显示所有可访问的合集列表（分页显示）
- 支持翻页浏览

带深链参数时：
- 展示合集信息（标题、描述、文件数量）
- 以媒体组形式发送合集中的所有文件（每组最多10个文件）
- 文件过多时自动分成多个媒体组发送

### 搜索合集

用户直接在聊天框输入关键词

Bot 会搜索标题或描述中包含该关键词的合集

返回匹配的合集列表（分页显示，每页10个）

支持翻页按钮浏览搜索结果

## 1.3 自动搬运（Admin 控制 + userbot worker）

管理员可开启/关闭自动搬运开关，由控制 Bot 下发任务给 userbot worker

worker 将指定频道消息转发到存储 Bot，支持三种范围：全部转发 / 按日期转发 / 按文件类型转发

按文件类型转发时需识别媒体组（album）内混合图片/视频并按条目类型精确过滤

# 技术架构

## 2.1 技术选型

### 核心框架
- **Bot 框架**：grammY + TypeScript
  - 原因：深链接支持好、会话管理强大、类型安全
  - 插件：@grammyjs/conversations (多步骤上传流程)
- **通信方式**：Long Polling（非 webhook）
  - 原因：连续上传更稳定、开发调试方便、无需公网 IP/SSL

### 数据存储
- **数据库**：PostgreSQL
  - collections 表：id, title, description, token, creator_id, created_at
  - media_files 表：id, collection_id, file_id, unique_file_id, type, order
  - users 表：id, telegram_id, is_admin, first_name, activated_at
  - settings 表：key, value (存储欢迎消息等配置)
- **ORM**：Prisma (类型安全 + 自动迁移)

### Userbot 集成
- **框架**：GramJS (官方 MTProto 实现)
- **功能**：监听频道消息 → 转发到 Bot → 自动归档

### 辅助工具
- **Token 生成**：nanoid (短 hash，适合深链)
- **模板渲染**：正则替换或 handlebars (占位符渲染)

## 2.2 项目目录结构

```
RSB-TgBot/
├── src/
│   ├── bot/
│   │   ├── index.ts              # Bot 主入口
│   │   ├── commands/             # 命令处理器
│   │   │   ├── start.ts          # /start 深链解析
│   │   │   ├── upload.ts         # /upload 上传流程
│   │   │   ├── display.ts        # /display 合集展示
│   │   │   └── publish.ts        # /publish 全员推送
│   │   ├── conversations/        # 多步骤会话
│   │   │   ├── uploadFlow.ts    # 上传→填写信息→保存
│   │   │   └── customizeStart.ts # 自定义欢迎消息
│   │   ├── middlewares/
│   │   │   ├── auth.ts           # 管理员权限检查
│   │   │   └── session.ts        # 会话管理
│   │   └── handlers/
│   │       ├── media.ts          # 媒体文件处理
│   │       └── callback.ts       # 按钮回调处理
│   ├── userbot/
│   │   ├── index.ts              # Userbot 主入口
│   │   ├── worker.ts             # 自动搬运逻辑
│   │   └── filters.ts            # 日期/类型过滤器
│   ├── database/
│   │   ├── schema.prisma         # Prisma 数据模型
│   │   ├── client.ts             # 数据库连接
│   │   └── migrations/           # 数据库迁移文件
│   ├── services/
│   │   ├── collection.ts         # 合集 CRUD
│   │   ├── media.ts              # 媒体文件管理
│   │   ├── user.ts               # 用户管理
│   │   └── template.ts           # 模板渲染服务
│   └── utils/
│       ├── token.ts              # Token 生成
│       ├── dedup.ts              # 去重逻辑
│       └── logger.ts             # 日志工具
├── prisma/
│   └── schema.prisma             # Prisma schema
├── .env                          # 环境变量
├── .env.example
├── package.json
├── tsconfig.json
└── README.md
```

## 2.3 技术难点与解决方案

### 难点 1：连续上传的会话状态管理
**问题**：用户连续发送多个媒体 → 输入标题/描述 → 保存，需要保持状态
**解决方案**：
- 使用 grammY conversations 插件
- 会话数据临时存储在内存或 Redis
- 超时自动清理未完成的上传

### 难点 2：媒体去重（unique_file_id）
**问题**：同一文件可能被多次上传，需要基于 `unique_file_id` 去重
**解决方案**：
- 数据库 `unique_file_id` 字段建立唯一索引
- 上传前查询是否已存在，存在则跳过并提示

### 难点 3：深链 Token 的唯一性与固定性
**问题**：每个合集需要一个永久不变的短 token
**解决方案**：
- 使用 `nanoid` 生成 8-10 位短 hash
- 数据库 token 字段唯一索引，冲突时重新生成
- 合集创建时生成，后续不可修改

### 难点 4：自动搬运的媒体组（album）识别
**问题**：Telegram 的 album 会作为多条消息发送，需要识别并按类型过滤
**解决方案**：
- 监听 `message.media_group_id`，相同 ID 的消息属于同一 album
- 缓存 media_group_id，延迟 1-2 秒后批量处理
- 按文件类型过滤时，逐条检查 `message.photo`/`message.video` 等

### 难点 5：全员推送的性能与限流
**问题**：向所有用户推送消息，可能触发 Telegram 限流
**解决方案**：
- 分批发送，每批 30 条，间隔 1 秒
- 记录发送失败的用户（bot 被 block），标记为非激活状态
- 使用队列（如 Bull）异步处理

### 难点 6：Premium Emoji 的存储与渲染
**问题**：Premium Emoji 是特殊 Unicode，需要正确存储和显示
**解决方案**：
- 数据库使用 UTF-8mb4 编码
- 直接存储原始文本，Telegram API 自动渲染
- 无需转义或特殊处理

### 难点 7：占位符渲染的安全性
**问题**：用户输入的模板可能包含恶意代码或注入
**解决方案**：
- 仅支持白名单占位符（如 `{{user_first_name}}`）
- 使用正则替换，不使用 eval 或动态执行
- 对用户输入进行 HTML 转义（如果涉及 Web 展示）

---

# 本地开发与部署

## 3.1 环境要求

- **Node.js**: v18 或更高版本
- **PostgreSQL**: v14 或更高版本
- **npm**: v9 或更高版本

## 3.2 本地开发启动

### 1. 克隆项目
```bash
git clone <repository-url>
cd RSB-TgBot
```

### 2. 安装依赖
```bash
npm install
```

### 3. 配置环境变量
```bash
# 复制环境变量模板
cp .env.example .env

# 编辑 .env 文件，填入以下配置：
# BOT_TOKEN=your_bot_token_here
# BOT_USERNAME=your_bot_username
# ADMIN_IDS=123456789,987654321
# DATABASE_URL=postgresql://user:password@localhost:5432/rsb_tgbot
# HTTP_PROXY=http://127.0.0.1:7890  # 可选，如果需要代理
# HTTPS_PROXY=http://127.0.0.1:7890  # 可选，如果需要代理
```

### 4. 设置数据库
```bash
# 创建数据库（在 PostgreSQL 中执行）
createdb rsb_tgbot

# 或使用 psql
psql -U postgres
CREATE DATABASE rsb_tgbot;
\q
```

### 5. 运行数据库迁移
```bash
npx prisma migrate dev
```

### 6. 生成 Prisma Client
```bash
npx prisma generate
```

### 7. 编译 TypeScript
```bash
npm run build
```

### 8. 启动 Bot
```bash
# 开发模式（自动重启）
npm run dev

# 生产模式
npm start
```

## 3.3 生产环境部署

### 方式一：使用 PM2（推荐）

```bash
# 1. 安装 PM2
npm install -g pm2

# 2. 启动应用
pm2 start dist/bot/index.js --name rsb-bot

# 3. 查看状态
pm2 status

# 4. 查看日志
pm2 logs rsb-bot

# 5. 设置开机自启动
pm2 startup
pm2 save

# 6. 重启应用
pm2 restart rsb-bot

# 7. 停止应用
pm2 stop rsb-bot
```

### 方式二：使用 systemd

创建 `/etc/systemd/system/rsb-bot.service`：

```ini
[Unit]
Description=RSB Telegram Bot
After=network.target postgresql.service

[Service]
Type=simple
User=your_user
WorkingDirectory=/path/to/RSB-TgBot
ExecStart=/usr/bin/node /path/to/RSB-TgBot/dist/bot/index.js
Restart=always
RestartSec=10
Environment=NODE_ENV=production

[Install]
WantedBy=multi-user.target
```

启动服务：
```bash
sudo systemctl daemon-reload
sudo systemctl enable rsb-bot
sudo systemctl start rsb-bot
sudo systemctl status rsb-bot
```

## 3.4 常用命令

```bash
# 查看数据库状态
npx prisma studio

# 重置数据库（危险操作！）
npx prisma migrate reset

# 更新依赖
npm update

# 检查代码
npm run lint  # 如果配置了 ESLint

# 运行测试
npm test  # 如果配置了测试
```

## 3.5 数据备份与恢复

### 为什么需要备份？

`npx prisma migrate reset` 会清空所有数据，包括用户、合集、媒体文件等。为了避免数据丢失，项目提供了备份机制。

### 备份表说明

项目创建了独立的备份表，这些表不会被 Prisma 管理，因此在 `migrate reset` 时不会被清空：

- `collections_backup` - 合集备份
- `media_files_backup` - 媒体文件备份
- `users_backup` - 用户备份
- `settings_backup` - 系统设置备份

### 使用方法

#### Linux/Mac 系统

```bash
# 1. 备份数据（在执行 migrate reset 之前）
chmod +x scripts/backup-data.sh
./scripts/backup-data.sh

# 2. 执行数据库重置
npx prisma migrate reset

# 3. 恢复数据
chmod +x scripts/restore-backup.sh
./scripts/restore-backup.sh
```

#### Windows 系统

```bash
# 1. 备份数据（在执行 migrate reset 之前）
scripts\backup-data.bat

# 2. 执行数据库重置
npx prisma migrate reset

# 3. 恢复数据
scripts\restore-backup.bat
```

### 备份特点

✅ **自动去重**：同一数据多次备份不会重复
✅ **保留历史**：每次备份都会记录时间戳
✅ **独立存储**：备份表不受 Prisma 迁移影响
✅ **智能恢复**：恢复时自动选择最新的备份数据

### 手动备份（推荐）

除了使用脚本，也建议定期使用 PostgreSQL 原生工具备份：

```bash
# 完整备份
pg_dump rsb_tgbot > backup_$(date +%Y%m%d_%H%M%S).sql

# 恢复
psql rsb_tgbot < backup_20260217_120000.sql
```

## 3.6 更新部署

```bash
# 1. 拉取最新代码
git pull

# 2. 安装新依赖
npm install

# 3. 运行数据库迁移
npx prisma migrate deploy

# 4. 重新编译
npm run build

# 5. 重启服务
pm2 restart rsb-bot
# 或
sudo systemctl restart rsb-bot
```

## 3.6 故障排查

### Bot 无法连接 Telegram API
- 检查网络连接
- 如果在中国大陆，确保配置了代理（HTTP_PROXY/HTTPS_PROXY）
- 验证 BOT_TOKEN 是否正确

### 数据库连接失败
- 检查 PostgreSQL 是否运行：`sudo systemctl status postgresql`
- 验证 DATABASE_URL 配置是否正确
- 确保数据库用户有足够权限

### 编译错误
- 删除 `node_modules` 和 `package-lock.json`，重新安装：
  ```bash
  rm -rf node_modules package-lock.json
  npm install
  ```

### 查看日志
```bash
# PM2 日志
pm2 logs rsb-bot

# systemd 日志
sudo journalctl -u rsb-bot -f
```
