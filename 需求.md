# Bot介绍
一个 Telegram Bot，用于将媒体以 Telegram file_id 的形式"索引存储"为合集，并通过 固定 token 的深链接分享合集。

# 功能概览
## 1.1 管理员（Admin）
### /start → 欢迎消息 + 合集列表

显示自定义欢迎消息（支持占位符渲染）

显示所有可访问的合集列表（分页显示，每页10个）

每个合集显示：标题、描述、文件数量、深链接、创建日期

支持翻页按钮浏览更多合集

### /setwelcome 自定义欢迎消息

管理员可设置 /start 命令的欢迎消息

支持占位符：{{user_first_name}}、{{user_last_name}}、{{user_username}}

支持 Premium Emoji（无需转义）

### /upload 文件上传

连续发送/转发媒体（photo/video/document/audio）

去重（基于 unique_file_id）

完成上传 → 填写标题/描述 → 💾 储存

标题相同的合集会自动追加文件（描述会被覆盖）

保存成功后：
- 固化合集（collection）
- 生成并固定深链 token（一个合集永远一个 token）
- 返回"储存完成 + 深链接 + 编辑/删除按钮"

### /display 合集文件展示

管理员查看全部已保存合集

显示合集 ID、标题、文件数量、深链接、创建日期

提示使用 /edit <ID> 编辑合集，/delete <ID> 删除合集

### /edit <ID> 编辑合集

显示合集信息和文件列表

提供"编辑标题/描述"按钮

为每个文件提供删除按钮（每行2个按钮）

点击删除按钮会显示文件预览并请求确认

编辑标题时，如果新标题与其他合集重复，会自动合并文件

### /delete <ID> 删除合集

删除指定合集及其所有文件

需要确认才能删除

### /publish 推送

向所有激活 Bot 的成员发送一条消息

支持占位符渲染与直接输入 Premium Emoji

## 1.2 用户（User）
### /start

无参数时：
- 显示欢迎消息
- 显示所有可访问的合集列表（分页显示）
- 支持翻页浏览

带深链参数时：
- 展示合集信息（标题、描述、文件数量）
- 以媒体组形式发送合集中的所有文件（每组最多10个文件）
- 文件过多时自动分成多个媒体组发送

### 搜索合集

用户直接在聊天框输入关键词

Bot 会搜索标题或描述中包含该关键词的合集

返回匹配的合集列表（分页显示，每页10个）

支持翻页按钮浏览搜索结果

## 1.3 自动搬运（Admin 控制 + userbot worker）

管理员可开启/关闭自动搬运开关，由控制 Bot 下发任务给 userbot worker

worker 将指定频道消息转发到存储 Bot，支持三种范围：全部转发 / 按日期转发 / 按文件类型转发

按文件类型转发时需识别媒体组（album）内混合图片/视频并按条目类型精确过滤

# 技术架构

## 2.1 技术选型

### 核心框架
- **Bot 框架**：grammY + TypeScript
  - 原因：深链接支持好、会话管理强大、类型安全
  - 插件：@grammyjs/conversations (多步骤上传流程)
- **通信方式**：Long Polling（非 webhook）
  - 原因：连续上传更稳定、开发调试方便、无需公网 IP/SSL

### 数据存储
- **数据库**：PostgreSQL
  - collections 表：id, title, description, token, creator_id, created_at
  - media_files 表：id, collection_id, file_id, unique_file_id, type, order
  - users 表：id, telegram_id, is_admin, first_name, activated_at
  - settings 表：key, value (存储欢迎消息等配置)
- **ORM**：Prisma (类型安全 + 自动迁移)

### Userbot 集成
- **框架**：GramJS (官方 MTProto 实现)
- **功能**：监听频道消息 → 转发到 Bot → 自动归档

### 辅助工具
- **Token 生成**：nanoid (短 hash，适合深链)
- **模板渲染**：正则替换或 handlebars (占位符渲染)

## 2.2 项目目录结构

```
RSB-TgBot/
├── src/
│   ├── bot/
│   │   ├── index.ts              # Bot 主入口
│   │   ├── commands/             # 命令处理器
│   │   │   ├── start.ts          # /start 深链解析
│   │   │   ├── upload.ts         # /upload 上传流程
│   │   │   ├── display.ts        # /display 合集展示
│   │   │   └── publish.ts        # /publish 全员推送
│   │   ├── conversations/        # 多步骤会话
│   │   │   ├── uploadFlow.ts    # 上传→填写信息→保存
│   │   │   └── customizeStart.ts # 自定义欢迎消息
│   │   ├── middlewares/
│   │   │   ├── auth.ts           # 管理员权限检查
│   │   │   └── session.ts        # 会话管理
│   │   └── handlers/
│   │       ├── media.ts          # 媒体文件处理
│   │       └── callback.ts       # 按钮回调处理
│   ├── userbot/
│   │   ├── index.ts              # Userbot 主入口
│   │   ├── worker.ts             # 自动搬运逻辑
│   │   └── filters.ts            # 日期/类型过滤器
│   ├── database/
│   │   ├── schema.prisma         # Prisma 数据模型
│   │   ├── client.ts             # 数据库连接
│   │   └── migrations/           # 数据库迁移文件
│   ├── services/
│   │   ├── collection.ts         # 合集 CRUD
│   │   ├── media.ts              # 媒体文件管理
│   │   ├── user.ts               # 用户管理
│   │   └── template.ts           # 模板渲染服务
│   └── utils/
│       ├── token.ts              # Token 生成
│       ├── dedup.ts              # 去重逻辑
│       └── logger.ts             # 日志工具
├── prisma/
│   └── schema.prisma             # Prisma schema
├── .env                          # 环境变量
├── .env.example
├── package.json
├── tsconfig.json
└── README.md
```

## 2.3 技术难点与解决方案

### 难点 1：连续上传的会话状态管理
**问题**：用户连续发送多个媒体 → 输入标题/描述 → 保存，需要保持状态
**解决方案**：
- 使用 grammY conversations 插件
- 会话数据临时存储在内存或 Redis
- 超时自动清理未完成的上传

### 难点 2：媒体去重（unique_file_id）
**问题**：同一文件可能被多次上传，需要基于 `unique_file_id` 去重
**解决方案**：
- 数据库 `unique_file_id` 字段建立唯一索引
- 上传前查询是否已存在，存在则跳过并提示

### 难点 3：深链 Token 的唯一性与固定性
**问题**：每个合集需要一个永久不变的短 token
**解决方案**：
- 使用 `nanoid` 生成 8-10 位短 hash
- 数据库 token 字段唯一索引，冲突时重新生成
- 合集创建时生成，后续不可修改

### 难点 4：自动搬运的媒体组（album）识别
**问题**：Telegram 的 album 会作为多条消息发送，需要识别并按类型过滤
**解决方案**：
- 监听 `message.media_group_id`，相同 ID 的消息属于同一 album
- 缓存 media_group_id，延迟 1-2 秒后批量处理
- 按文件类型过滤时，逐条检查 `message.photo`/`message.video` 等

### 难点 5：全员推送的性能与限流
**问题**：向所有用户推送消息，可能触发 Telegram 限流
**解决方案**：
- 分批发送，每批 30 条，间隔 1 秒
- 记录发送失败的用户（bot 被 block），标记为非激活状态
- 使用队列（如 Bull）异步处理

### 难点 6：Premium Emoji 的存储与渲染
**问题**：Premium Emoji 是特殊 Unicode，需要正确存储和显示
**解决方案**：
- 数据库使用 UTF-8mb4 编码
- 直接存储原始文本，Telegram API 自动渲染
- 无需转义或特殊处理

### 难点 7：占位符渲染的安全性
**问题**：用户输入的模板可能包含恶意代码或注入
**解决方案**：
- 仅支持白名单占位符（如 `{{user_first_name}}`）
- 使用正则替换，不使用 eval 或动态执行
- 对用户输入进行 HTML 转义（如果涉及 Web 展示）

---

# 本地开发与部署

## 3.1 环境要求

- **Node.js**: v18 或更高版本
- **PostgreSQL**: v14 或更高版本
- **npm**: v9 或更高版本

## 3.2 本地开发启动

### 1. 克隆项目
```bash
git clone <repository-url>
cd RSB-TgBot
```

### 2. 安装依赖
```bash
npm install
```

### 3. 配置环境变量
```bash
# 复制环境变量模板
cp .env.example .env

# 编辑 .env 文件，填入以下配置：
# BOT_TOKEN=your_bot_token_here
# BOT_USERNAME=your_bot_username
# ADMIN_IDS=123456789,987654321
# DATABASE_URL=postgresql://user:password@localhost:5432/rsb_tgbot
# HTTP_PROXY=http://127.0.0.1:7890  # 可选，如果需要代理
# HTTPS_PROXY=http://127.0.0.1:7890  # 可选，如果需要代理
```

### 4. 设置数据库
```bash
# 创建数据库（在 PostgreSQL 中执行）
createdb rsb_tgbot

# 或使用 psql
psql -U postgres
CREATE DATABASE rsb_tgbot;
\q
```

### 5. 运行数据库迁移
```bash
npx prisma migrate dev
```

### 6. 生成 Prisma Client
```bash
npx prisma generate
```

### 7. 编译 TypeScript
```bash
npm run build
```

### 8. 启动 Bot
```bash
# 开发模式（自动重启）
npm run dev

# 生产模式
npm start
```
